{"entries":[{"timestamp":1764715701969,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":3978,"length1":0,"diffs":[[1,"    //joyState.deg\n    //joyState.strength\n\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":531,"length1":44,"diffs":[[1,"    \"testFiles\": [],\n"]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"added","filename":"main.blocks","value":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"}]}],"snapshots":[{"timestamp":1764715701968,"editorVersion":"8.0.18","text":{"README.md":"# PeeWee projects P1A 2023/2024\n\n## Youtube video\n\nLink: [https://www.youtube.com/watch?v=8uSzMZzNKQE](https://www.youtube.com/watch?v=8uSzMZzNKQE)\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **github repo URL** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","main.ts":"type Buttons = {\n    a: boolean,\n    b: boolean,\n    c: boolean,\n    d: boolean,\n    e: boolean,\n    f: boolean,\n    p: boolean\n}\ntype LineSensors = {\n    r: boolean,\n    c: boolean,\n    l: boolean\n}\nenum Pins {\n    wr = DigitalPin.P8,\n    wl = DigitalPin.P13,\n    r = DigitalPin.P12,\n    l = DigitalPin.P14,\n    c = DigitalPin.P15,\n    trig = DigitalPin.P2,\n    echo = DigitalPin.P1,\n    ltop = DigitalPin.P16,\n    lbottom = DigitalPin.P0\n}\nenum ServoDirection {\n    Left = 2,\n    Center = 1,\n    Right = 0\n}\n\nconst lineSensors: LineSensors = { r: false, c: false, l: false }\nlet data: Buttons = { a: false, b: false, c: false, d: false, e: false, f: false, p: false }\nlet ultrasonicData: Array<number> = []\nconst allIRPins: Array<number> = [Pins.wr, Pins.wl, Pins.r, Pins.l, Pins.c, Pins.trig, Pins.echo, Pins.ltop, Pins.lbottom]\nfor (let pin of allIRPins) {\n    pins.setPull(pin, PinPullMode.PullNone);\n}\n\nconst stripTop = neopixel.create(Pins.ltop as number, 4, NeoPixelMode.RGB)\nconst stripBottom = neopixel.create(Pins.lbottom as number, 38, NeoPixelMode.RGB)\nconst stripBottomDown = stripBottom.range(0, 28)\nconst stripBottomFrontRight = stripBottom.range(28, 4)\nconst stripBottomFrontCenter = stripBottom.range(31, 4)\nconst stripBottomFrontLeft = stripBottom.range(34, 4)\n\nconst SHIFT: number = 100\nconst PERIOD: number = 200\nlet powerReduction: number = 3\n\nlet isUp: boolean = false\nlet isObstacleDetected: boolean = false\nlet isBeeping: boolean = false\nlet isDriving: boolean = false\n\nmusic.setVolume(220)\nstripBottomDown.setBrightness(10)\nstripBottomDown.showRainbow(1, 360)\ndoPairing();\n\n// can be used to stop motors: carMotor()\nconst carMotor = (leftwheel: number = 0, rightwheel: number = 0): void => {\n    if (leftwheel === 0 && rightwheel === 0) { PCAmotor.MotorStopAll(); return; }\n\n    PCAmotor.MotorRun(PCAmotor.Motors.M1, Math.map(rightwheel, -100, 100, -190, 190))\n    PCAmotor.MotorRun(PCAmotor.Motors.M4, Math.map(leftwheel, -100, 100, -255, 255))\n}\n\nconst servoMove = (direction: ServoDirection): void => {\n    PCAmotor.GeekServo(PCAmotor.Servos.S1, 500 + 1000 * direction)\n    basic.pause(600)\n    PCAmotor.StopServo(PCAmotor.Servos.S1)\n}\n\nconst controlBottomLEDs = (centralIR: boolean = false): void => {\n    if (centralIR && !isUp) {\n        stripBottomDown.clear()\n        isUp = true\n    } else if (!centralIR && isUp) {\n        stripBottomDown.showRainbow(1, 360)\n        isUp = false\n    }\n    stripBottomDown.rotate()\n    stripBottomDown.show()\n}\n\nconst obstacleDetector = (distance: number = 0): void => {\n    ultrasonicData.unshift(distance)\n    console.log(distance)\n    if (ultrasonicData.length > 5) {\n        ultrasonicData.pop()\n        const average: number = ultrasonicData.reduce((sum, currentValue) => sum + currentValue, 0) / ultrasonicData.length\n\n        if (average > 1 && average < 6 && !isObstacleDetected) {\n            music._playDefaultBackground(music.builtInPlayableMelody(Melodies.Wawawawaa), music.PlaybackMode.LoopingInBackground)\n            stripTop.showColor(neopixel.hsl(0, 100, 10))\n            isObstacleDetected = true\n        } else if ((average >= 6 || average <= 1) && isObstacleDetected) {\n            music.stopAllSounds()\n            stripTop.clear()\n            isObstacleDetected = false\n        }\n        stripTop.show()\n\n    }\n}\n\nconst reset = (): void => {\n    carMotor()\n    music.stopAllSounds()\n    stripTop.clear()\n    stripTop.show()\n    stripBottomDown.clear()\n    stripBottomDown.show()\n    stripBottomFrontLeft.clear()\n    stripBottomFrontLeft.show()\n    stripBottomFrontCenter.clear()\n    stripBottomFrontCenter.show()\n    stripBottomFrontRight.clear()\n    stripBottomFrontRight.show()\n}\n\nbasic.forever(function (): void {\n    controlBottomLEDs(!!pins.digitalReadPin(Pins.c as number))\n    //obstacleDetector(Sensors.ping(Pins.trig as number, Pins.echo as number, 15))\n    \n    if (lastCall + 3000 > control.millis()) carMotor();\n\n    basic.pause(PERIOD)\n})\n\nconst carMovement = (): void => {\n    //joyState.deg\n    //joyState.strength\n\n    // buttons\n    if (data.a && powerReduction < 6) powerReduction += 0.5\n    else if (data.b && powerReduction > 1) powerReduction -= 0.5\n\n    if (data.c && !isBeeping && !isObstacleDetected) {\n        music._playDefaultBackground(music.builtInPlayableMelody(Melodies.PowerUp), music.PlaybackMode.LoopingInBackground)\n        isBeeping = true\n    } else if (!data.c && isBeeping && !isObstacleDetected) {\n        music.stopMelody(MelodyStopOptions.All)\n        isBeeping = false\n    }\n    // servo\n    if (data.e) {\n        carMotor()\n        servoMove(ServoDirection.Center)\n    } else if (data.f) {\n        carMotor()\n        servoMove(ServoDirection.Left)\n    } else if (data.d) {\n        carMotor()\n        servoMove(ServoDirection.Right)\n    }\n\n    // leds\n    stripBottomFrontRight.clear()\n    stripBottomFrontCenter.clear()\n    stripBottomFrontLeft.clear()\n    if (joyState.dirArrow === ArrowNames.East || joyState.dirArrow === ArrowNames.NorthEast) {\n        stripBottomFrontRight.showColor(neopixel.hsl(120, 100, 10))\n        stripBottomFrontRight.show()\n    } else if (joyState.dirArrow === ArrowNames.West || joyState.dirArrow === ArrowNames.NorthWest) {\n        stripBottomFrontLeft.showColor(neopixel.hsl(270, 100, 10))\n        stripBottomFrontLeft.show()\n    } else if (joyState.dirArrow === ArrowNames.North && joyState.strength > 5) {\n        stripBottomFrontCenter.showColor(neopixel.hsl(230, 100, 15))\n        stripBottomFrontCenter.show()\n    } else if (joyState.dirArrow === ArrowNames.South) {\n        stripBottomFrontCenter.showColor(neopixel.hsl(0, 100, 10))\n        stripBottomFrontCenter.show()\n    }\n\n    driveFromJoy(joyState.deg, joyState.strength / powerReduction);\n}\n\nfunction driveFromJoy(deg: number, strength: number) {\n    const rad = deg * Math.PI / 180\n\n    const drive = Math.cos(rad)   // dopředná / zpětná\n    const turn = Math.sin(rad)    // otáčení\n\n    let left = drive + turn\n    let right = drive - turn\n\n    let maxMag = Math.max(Math.abs(left), Math.abs(right))\n    if (maxMag > 1) {\n        left /= maxMag\n        right /= maxMag\n    }\n\n    const scale = strength / 100\n    let leftOut = Math.round(left * scale * 100)\n    let rightOut = Math.round(right * scale * 100)\n\n    if (leftOut > 100) leftOut = 100\n    if (leftOut < -100) leftOut = -100\n    if (rightOut > 100) rightOut = 100\n    if (rightOut < -100) rightOut = -100\n\n    carMotor(leftOut, rightOut)\n}","radiorx.ts":"radio.setFrequencyBand(66)\nradio.setGroup(10)\nradio.setTransmitSerialNumber(true)\nlet pairedSerialNo = -1\nlet lastCall = control.millis();\n\ntype ButtonKey = \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\" | \"P\"\n\ndeclare type ButtonStateItem = {\n    key: ButtonKey\n    value: boolean\n}\ndeclare type JoyStateItem = {\n    dirArrow: number,\n    strength: number,\n    deg: number\n}\n\nconst btnState: Array<ButtonStateItem> = [\n    { key: \"A\", value: false },\n    { key: \"B\", value: false },\n    { key: \"C\", value: false },\n    { key: \"D\", value: false },\n    { key: \"E\", value: false },\n    { key: \"F\", value: false },\n    { key: \"P\", value: false }\n]\nconst joyState: JoyStateItem = {\n    dirArrow: 0,\n    strength: 0,\n    deg: 0\n}\n\nlet pairingMode = false\nconst doPairing = () => {\n    pairingMode = true\n    const start = control.millis();\n    while (pairingMode) {\n        basic.showIcon(IconNames.Pitchfork, 100)\n        basic.clearScreen();\n        if ((start + 10000) < control.millis())\n            pairingMode = false;\n        else\n            basic.pause(300)\n    }\n}\ninput.onLogoEvent(TouchButtonEvent.LongPressed, doPairing)\nradio.onReceivedValue(function (name: string, value: number) {\n    if (name === \"serial\" && pairingMode) {\n        if (radio.receivedPacket(RadioPacketProperty.SerialNumber) === value) {\n            pairedSerialNo = value\n            basic.showIcon(IconNames.Happy, 0)\n            music.playTone(440, 300)\n            pairingMode = false\n        }\n    }\n})\n\nradio.onReceivedNumber(function (n: number) {\n    if (pairedSerialNo !== radio.receivedPacket(RadioPacketProperty.SerialNumber)) return;\n\n    let buttonsMask = n & 0b1111111      // bity 0–6\n    let dir = (n >> 7) & 0b111           // bity 7–9\n    let strength = (n >> 10) & 0b1111111 // bity 10–16\n    let deg = (n >> 17) & 0b111111111    // bity 17–25\n\n    for (let i = 0; i < btnState.length; i++) {\n        btnState[i].value = (buttonsMask & (1 << i)) != 0\n    }\n    joyState.dirArrow = dir\n    joyState.strength = strength\n    joyState.deg = deg\n\n    lastCall = control.millis();\n\n    refreshDisplay();\n    //remap\n    data.a = btnState[0].value;\n    data.b = btnState[1].value;\n    data.c = btnState[2].value;\n    data.d = btnState[3].value;\n    data.e = btnState[4].value;\n    data.f = btnState[5].value;\n    data.p = btnState[6].value;\n\n    carMovement();\n})\n\nfunction getImage(ch: string): Image {\n    let result: Image = images.createImage(`\n        . . . . .\n        . . . . .\n        . # # # .\n        . . . . .\n        . . . . .\n        `)\n\n    switch (ch.charAt(0).toUpperCase()) {\n        case \"A\":\n            result = images.createImage(`\n                . # # # .\n                # . . . #\n                # # # # #\n                # . . . #\n                # . . . #\n                `)\n            break;\n        case \"B\":\n            result = images.createImage(`\n                # # # . .\n                # . . # .\n                # # # . .\n                # . . # .\n                # # # . .\n                `)\n            break;\n        case \"C\":\n            result = images.createImage(`\n                . # # # .\n                # . . . .\n                # . . . .\n                # . . . .\n                . # # # .\n                `)\n            break;\n        case \"D\":\n            result = images.createImage(`\n                # # # . .\n                # . . # .\n                # . . # .\n                # . . # .\n                # # # . .\n                `)\n            break;\n        case \"E\":\n            result = images.createImage(`\n                # # # # #\n                # . . . .\n                # # # # .\n                # . . . .\n                # # # # #\n                `)\n            break;\n        case \"F\":\n            result = images.createImage(`\n                # # # # #\n                # . . . .\n                # # # # .\n                # . . . .\n                # . . . .\n                `)\n            break;\n        case \"P\":\n            result = images.createImage(`\n                # # # # .\n                # . . . #\n                # # # # .\n                # . . . .\n                # . . . .\n                `)\n            break;\n    }\n\n    const arrNo: number = ch.charCodeAt(0) - 48\n    if (arrNo >= 0 && arrNo <= 7) result = images.arrowImage(arrNo);\n\n    return result;\n}\n\nfunction refreshDisplay() {\n    let imageToShow: Image = getImage(\"-\");\n    if (joyState.strength > 3) {\n        imageToShow = getImage(joyState.dirArrow.toString())\n    } else {\n        joyState.dirArrow = 0\n        joyState.deg = 0\n    }\n    for (let btn of btnState) {\n        if (btn.value) {\n            imageToShow = getImage(btn.key)\n            break;\n        }\n    }\n    imageToShow.showImage(0, 0);\n}\n","pxt.json":"{\n    \"name\": \"pxt-Motor:bit\",\n    \"version\": \"0.0.0\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"neopixel\": \"github:microsoft/pxt-neopixel#v0.7.5\",\n        \"pxt-magicbit-pca9685\": \"github:TomasKazda/pxt-magicbit-pca9685#1e097c914b2c7ed1f4071d7b6288ef64812030e2\",\n        \"pxt-sensors\": \"github:tomaskazda/pxt-sensors#a4146d725fe882187db670cb094772d4e747a220\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"main.ts\",\n        \"radiorx.ts\"\n    ],\n    \"testFiles\": [],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"6.0.28\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}}],"shares":[],"lastSaveTime":1764715742249}